#!/usr/bin/perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"File/pushd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_PUSHD';
  use strict;use warnings;package File::pushd;our$VERSION='1.005';our@EXPORT=qw(pushd tempd);our@ISA=qw(Exporter);use Exporter;use Carp;use Cwd qw(getcwd abs_path);use File::Path qw(rmtree);use File::Temp qw();use File::Spec;use overload q{""}=>sub {File::Spec->canonpath($_[0]->{_pushd})},fallback=>1;sub pushd {my ($target_dir,$options)=@_;$options->{untaint_pattern}||=qr{^([-+@\w./]+)$};$target_dir="." unless defined$target_dir;croak "Can't locate directory $target_dir" unless -d $target_dir;my$tainted_orig=getcwd;my$orig;if ($tainted_orig =~ $options->{untaint_pattern}){$orig=$1}else {$orig=$tainted_orig}my$tainted_dest;eval {$tainted_dest=$target_dir ? abs_path($target_dir): $orig};croak "Can't locate absolute path for $target_dir: $@" if $@;my$dest;if ($tainted_dest =~ $options->{untaint_pattern}){$dest=$1}else {$dest=$tainted_dest}if ($dest ne $orig){chdir$dest or croak "Can't chdir to $dest\: $!"}my$self=bless {_pushd=>$dest,_original=>$orig },__PACKAGE__;return$self}sub tempd {my ($options)=@_;my$dir;eval {$dir=pushd(File::Temp::tempdir(CLEANUP=>0),$options)};croak $@ if $@;$dir->{_tempd}=1;return$dir}sub preserve {my$self=shift;return 1 if!$self->{"_tempd"};if (@_==0){return$self->{_preserve}=1}else {return$self->{_preserve}=$_[0]? 1 : 0}}sub DESTROY {my ($self)=@_;my$orig=$self->{_original};chdir$orig if$orig;if ($self->{_tempd}&& !$self->{_preserve}){my$err=do {local $@;eval {rmtree($self->{_pushd})};$@};carp$err if$err}}1;
FILE_PUSHD

$fatpacked{"Library/Build.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIBRARY_BUILD';
  package Library::Build;use 5.008005;use strict;use warnings;use Getopt::Long qw(:config gnu_getopt no_auto_abbrev no_ignore_case);use Library::Build::Config;use Library::Build::HTTP;use Library::Build::Logger;use Library::Build::Archive;use File::Spec::Functions qw(catdir catfile);use File::Spec;use File::pushd 'pushd';use File::Temp 'tempdir';use File::Copy qw(move copy);use File::Path qw(rmtree mkpath);use POSIX 'strftime';our$VERSION="0.01";sub help {print <<"..."}sub new {my$class=shift;bless {},$class}sub config {shift->{config}}sub http {shift->{http}}sub shell {shift->{shell}}sub parse_options {my ($self,@argv)=@_;local@ARGV=@argv;GetOptions "cache_dir=s"=>\(my$cache_dir),"build_dir=s"=>\(my$build_dir),"prefix=s"=>\(my$prefix),"shell=s"=>\(my$shell),"l|list"=>\(my$show_list),"h|help"=>sub {help();exit},or do {help();exit};$self->{shell}=$shell || $ENV{SHELL}|| "/bin/bash";$self->{config}=Library::Build::Config->new(prefix=>$prefix,cache_dir=>$cache_dir,build_dir=>$build_dir,);if ($show_list){chdir$self->config->cache_dir;print "pre downloaded libraries are:\n";for my$file (sort glob "*"){my$mtime=(stat$file)[9];printf "[%s] %s\n",strftime("%F %T",localtime($mtime)),$file}exit}$ENV{PATH}=catdir($self->config->prefix,"bin").":$ENV{PATH}";$self->{http}=Library::Build::HTTP->new;$self->{argv}=shift@ARGV;$self}sub build {my$self=shift;my$argv=shift || $self->{argv}or croak "ERROR don't know what to do!";my$where=$self->where($argv);my$file=$self->get(where=>$where,argv=>$argv);$self->_build($file)}sub _build {my ($self,$file)=@_;$self->clean_build_dir;my$build_dir=catdir($self->config->build_dir,strftime("%Y%m%d%H%M%S_$$",localtime),);mkpath$build_dir or die;chdir$build_dir or die;Library::Build::Archive ->new(archive=>$file)->extract(to=>".");my ($dir)=grep -d,glob "*";chdir$dir or die;$ENV{PREFIX}=$self->config->PREFIX;$ENV{LDFLAGS}=$self->config->LDFLAGS;$ENV{CPPFLAGS}=$self->config->CPPFLAGS;$ENV{PKG_CONFIG_PATH}=$self->config->PKG_CONFIG_PATH;print <<"...";exec$self->shell,"-l";die}sub clean_build_dir {my$self=shift;my$guard=pushd$self->config->build_dir;my@dir=grep -d,glob "*";my$now=time;for my$dir (@dir){my$mtime=(stat$dir)[9];if ($now - $mtime > 60 * 60 * 24 * 14){info "remove 14 days before build dir $dir";rmtree$dir or die $!}}}sub where {my ($self,$argv)=@_;if ($argv =~ /^(https?|ftp)/){return "http"}else {return "cache"}}sub get {my ($self,%opt)=@_;my$where=$opt{where}or die;my$argv=$opt{argv}or die;if ($where eq 'http'){$self->http_get($argv)}elsif ($where eq 'cache'){$self->cache_get($argv)}else {die}}sub cache_get {my ($self,$file)=@_;my$guard=pushd$self->config->cache_dir;my ($matched)=glob "$file*";if ($matched){return catfile($self->config->cache_dir,$matched)}else {croak "ERROR cannot find file matching $file"}}sub http_get {my ($self,$url)=@_;my$downloaded_file;my$tempdir=tempdir CLEANUP=>1;{my$guard=pushd$tempdir;xsystem($self->http->command,@{$self->http->option},$url);my ($archive)=glob "*";croak "ERROR missing archive" unless$archive;if ($url =~ /github\.com/ && $archive !~ /(tgz|tar\.gz|zip)$/){debug "github filename fix";my$type=$url =~ /(tar\.gz|tarball)/ ? "tar.gz" : $url =~ /zip/ ? "zip" : die;debug "rename %s %s",$archive,"$archive.$type";move$archive,"$archive.$type" or die $!;$archive="$archive.$type"}my$extracter=Library::Build::Archive->new(archive=>$archive);$extracter->extract or croak "ERROR cannot determine of top dir of %s",$archive;my$natural_name=$extracter->natural_name;my$target=catfile($self->config->cache_dir,$natural_name);if (-e $target){info "-> already exists $target, shouldn't have downloaded it...";unlink$target or die $!}move$archive,$target or die $!;$downloaded_file=$target;debug "downloaded file is $downloaded_file"}rmtree$tempdir;return$downloaded_file}sub xsystem {my@cmd=@_;info "-> @cmd";!system@cmd or croak "=> ERROR @cmd"}1;
  Usage:
      > library-build [file|url]
  
  Example:
      > library-build http://ftp.gnu.org/gnu/bash/bash-4.3.tar.gz
      > library-build https://github.com/shoichikaji/Path-Maker/zipball/master
  
  Options:
      --cache_dir   dir to store downloaded file, default \$HOME/.library-build/cache
      --build_dir   dir in which libraries to be built, default \$HOME/.library-build/build
      --prefix      dir to install libraries, default \$HOME/local
      --shell       your shell, default \$SHELL
      --list, -l    show list of downloaded libraries
      --help, -h    show this help message
  ...
  ----------------------------------------------
  Set the following environment variables:
  
  PREFIX          $ENV{PREFIX}
  CPPFLAGS        $ENV{CPPFLAGS}
  LDFLAGS         $ENV{LDFLAGS}
  PATH            $ENV{PATH}
  PKG_CONFIG_PATH $ENV{PKG_CONFIG_PATH}
  
  How to compile, for example;
  ./configure --help
  ./configure --prefix=\$PREFIX
  
  Now invoke new shell @{[$self->shell]} -l
  ---------------------------------------------
  ...
LIBRARY_BUILD

$fatpacked{"Library/Build/Archive.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIBRARY_BUILD_ARCHIVE';
  package Library::Build::Archive;use strict;use warnings;our$VERSION="0.001";my%TYPE=('tar.gz'=>'tar.gz','tgz'=>'tar.gz','zip'=>'zip','tar.xz'=>'tar.xz','txz'=>'tar.xz','tar.bz2'=>'tar.bz2','tbz'=>'tar.bz2',);my$TYPE_REGEXP=do {my$type=join "|",map {s/\./\\./g;$_}keys%TYPE;qr/$type/};sub new {my ($class,%opt)=@_;my$self;my$archive=$self->{archive}=$opt{archive}or die "missing archive";my$type=$opt{type};unless ($type){if ($archive =~ /($TYPE_REGEXP)$/){$type=$1}else {die "ERROR cannot determine archive type: $archive"}}$self->{type}=$TYPE{$type}or die "ERROR invalid archive type: $type";bless$self,$class}sub type {shift->{type}}sub archive {shift->{archive}}sub extract {my ($self,%option)=@_;my$to=$option{to};if ($to &&!-d $to){die "ERROR missing directory '$to'"}my$archive=$self->{archive};my$type=$self->{type};my%original=map {$_=>1}glob "*";my@cmd;if ($type eq 'tar.gz'){push@cmd,"tar","xzf",$archive,$to ? (-C=>$to): ()}elsif ($type eq 'tar.bz2'){push@cmd,"tar","xjf",$archive,$to ? (-C=>$to): ()}elsif ($type eq 'tar.xz'){push@cmd,"tar","xJf",$archive,$to ? (-C=>$to): ()}elsif ($type eq 'zip'){push@cmd,'unzip',"-q",$archive,$to ? (-d=>$to): ()}else {die}!system@cmd or die "ERRRO failed @cmd\n";my@extracted=grep {!$original{$_}}glob "*";die "ERROR failed to extract $archive" unless@extracted;if (@extracted > 1){warn "WARN $archive yields not one directory but followings:\n";warn "  $_\n" for sort@extracted}$self->{top_dir}=$extracted[0];return$self->{top_dir}}sub natural_name {my$self=shift;my$top_dir=$self->{top_dir}or die "ERROR don't invoke natural_name() method before extract()";my$type=$self->{type};"$top_dir.$type"}1;
LIBRARY_BUILD_ARCHIVE

$fatpacked{"Library/Build/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIBRARY_BUILD_CONFIG';
  package Library::Build::Config;use strict;use warnings;our$VERSION="0.001";use File::Spec::Functions qw(catdir catfile);use File::Spec;use File::Path qw(mkpath);sub new {my ($class,%opt)=@_;my$home=$ENV{HOME}or die "ERROR cannot determine prefix direcotry";my$prefix=$opt{prefix}|| catdir($home,"local");unless (-d $prefix){mkpath$prefix or die "ERROR cannot mkpath $prefix: $!"}my$cache_dir=$opt{cache_dir}|| catdir($home,".library-build/cache");my$build_dir=$opt{build_dir}|| catdir($home,".library-build/build");for my$dir (grep!-d,$cache_dir,$build_dir){mkpath$dir or die "ERROR cannot mkpath $dir: $!"}s{/$}{} for$prefix,$cache_dir,$build_dir;bless {prefix=>$prefix,cache_dir=>$cache_dir,build_dir=>$build_dir,},$class}sub prefix {shift->{prefix}}sub PREFIX {shift->{prefix}}sub build_dir {shift->{build_dir}}sub cache_dir {shift->{cache_dir}}sub PATH {my$prefix=shift->prefix;"$prefix/bin"}sub LDFLAGS {my$prefix=shift->prefix;"-L$prefix/lib -Wl,-rpath,$prefix/lib"}sub CPPFLAGS {my$prefix=shift->prefix;"-I$prefix/include"}sub PKG_CONFIG_PATH {my$prefix=shift->prefix;"$prefix/lib/pkgconfig"}1;
LIBRARY_BUILD_CONFIG

$fatpacked{"Library/Build/HTTP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIBRARY_BUILD_HTTP';
  package Library::Build::HTTP;use strict;use warnings;our$VERSION="0.001";use File::Spec;sub new {my$class=shift;my$self=bless {command=>"",option=>[]},$class;$self->build}sub command {shift->{command}}sub option {shift->{option}}sub build {my$self=shift;if ($self->which("curl")){$self->{command}="curl";$self->{option}=["-skLO"]}elsif ($self->which("wget")){$self->{command}="wget";$self->{option}=["--no-check-certificate"]}elsif ($self->which("fetch")){$self->{command}="fetch";$self->{option}=[]}else {die "ERROR cannot find curl, wget, nor fetch!\n"}$self}sub which {my ($self,$cmd)=@_;for my$path (File::Spec->path){my$try=File::Spec->catfile($path,$cmd);return$try if -x $try &&!-d $try}return}1;
LIBRARY_BUILD_HTTP

$fatpacked{"Library/Build/Logger.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIBRARY_BUILD_LOGGER';
  package Library::Build::Logger;use strict;use warnings;our$VERSION="0.001";use Carp ();$Carp::Internal{(__PACKAGE__)}++;use Exporter 'import';our@EXPORT=qw(info croak debug);use constant INTERACTIVE=>-t *STDOUT;my%color=(red=>31,green=>32,white=>37,);sub debug {return if!$ENV{LIBRARY_BUILD_DEBUG};my$format=@_==1 ? "%s" : shift;$format =~ s/\n$//;my$str=sprintf$format,@_;warn "[DEBUG] $str\n"}sub info {my$format=@_==1 ? "%s" : shift;$format =~ s/\n$//;my$str=sprintf$format,@_;if (INTERACTIVE){warn "\e[1;$color{white}m$str\e[m\n"}else {warn$str,"\n"}}sub croak {my$format=@_==1 ? "%s" : shift;$format =~ s/\n$//;my$str=sprintf$format,@_;if (INTERACTIVE){Carp::croak("\e[1;$color{red}m$str\e[m")}else {Carp::croak($str)}}1;
LIBRARY_BUILD_LOGGER

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
     if (my $fat = $_[0]{$_[1]}) {
       return sub {
         return 0 unless length $fat;
         $fat =~ s/^([^\n]*\n?)//;
         $_ = $1;
         return 1;
       };
     }
     return;
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;
use utf8;
use Library::Build;

my $builder = Library::Build->new;
$builder->parse_options(@ARGV);
$builder->build;

__END__

=head1 NAME

library-build - build library

=head1 AUTHOR

Shoichi Kaji

=cut

